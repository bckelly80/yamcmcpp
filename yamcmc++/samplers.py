"""
This file contains the class definition for the sampler MCMCSample classes.
"""

__author__ = 'Brandon C. Kelly'

import numpy as np
from matplotlib import pyplot as plt
from statsmodels.tsa import arima_process, arima_model


class MCMCSample(object):
    """
    Class object for parameter samples generated by a yamcmc++ sampler. This class contains a dictionary of samples
    generated by an MCMC sampler for a set of parameters, as well as methods for plotting and summarizing the results.

    In general, the MCMCSample object is empty upon instantiation. One adds parameters to the dictionary through the
    AddStep method of a Sampler object. Running a Sampler object then fills the dictionary up with the parameter values.
    After running a Sampler object, the MCMCSample object will contain the parameter values, which can then be analyzed
    further.

    Alternatively, one can load the parameters and their values from a file. This is done through the method
    generate_from_file. This is helpful if one has a set of MCMC samples generated by a different program.
    """

    def __init__(self, filename=None):
        """
        Constructor for an MCMCSample object. If no arguments are supplied, then this just creates an empty dictionary
        that will contain the MCMC samples. In this case parameters are added to the dictionary through the addstep
        method of a Sampler object, and the values are generated by running the Sampler object. Otherwise, if a
        filename is supplied then the parameter names and MCMC samples are read in from that file.

        :param filename: A string giving the name of an asciifile containing the MCMC samples.
        """
        self._samples = dict()  # Empty dictionary. We will place the samples for each tracked parameter here.
        if filename is not None:
            # Construct MCMCSample object by reading in MCMC samples from one or more asciifiles.
            self.generate_from_file([filename])

    def get_samples(self, name):
        """
        Returns a copy of the numpy array containing the samples for a parameter. This is safer then directly
        accessing the dictionary object containing the samples to prevent one from inadvertently changes the values of
        the samples output from an MCMC sampler.

        :param name: The name of the parameter for which the samples are desired.
        """
        return self._samples[name].copy()

    def generate_from_file(self, filename):
        """
        Build the dictionary of parameter samples from an ascii file of MCMC samples. The first line of this file
        should contain the parameter names.

        :param filename: The name of the file containing the MCMC samples.
        """
        # TODO: put in exceptions to make sure files are ready correctly
        for fname in filename:
            file = open(fname, 'r')
            name = file.readline()
            # Grab the MCMC output
            trace = np.genfromtxt(fname, skip_header=1)
            if name not in self._samples:
                # Parameter is not already in the dictionary, so add it. Otherwise do nothing.
                self._samples[name] = trace


    def autocorr_timescale(self, trace, order=(1, 0)):
        """
        Compute the autocorrelation time scale using an ARMA(p,q) model.

        :param trace: The parameter trace, a numpy array.
        :param order: The order of the ARMA(p,q) model, a tuple.
        """
        arma_model = arima_model.ARMA(trace, order=order)
        print "Getting model ACF for calculating the autocorrelation timescale..."
        arma_result = arma_model.fit(disp=-1)

        # Grab the estimated values of the AR and MA coefficients
        arcoefs = np.ones(order[0] + 1)
        macoefs = np.ones(order[1] + 1)
        # Need to convert the output to the input expected when computing the model autocorrelation function.
        arcoefs[1:] = -1.0 * arma_result.arparams
        macoefs[1:] = arma_result.maparams

        # Compute the model ACF
        model_acf = arima_process.arma_acf(arcoefs, macoefs, trace.size)

        acf_timescale = model_acf[0] + 2.0 * model_acf[1:].sum()
        return acf_timescale

    def effective_samples(self, name):
        """
        Return the effective number of independent samples of the MCMC sampler.

        :param name: The name of the parameter to compute the effective number of independent samples for.
        """
        traces = self._samples[name]  # Get the sampled parameter values

        if traces.ndim == 1:
            # Parameter is scalar valued, so this is easy
            acf_timescale = self.autocorr_timescale(traces)
            nsamples_effective = traces.size / acf_timescale
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            nsamples_effective = np.zeros(traces.shape[1])

            traces = traces - traces.mean(axis=0)

            for i in xrange(traces.shape[1]):
                acf_timescale = self.autocorr_timescale(traces[:, i])
                nsamples_effective[i] = traces.shape[0] / acf_timescale

        return nsamples_effective

    def plot_trace(self, name):
        """
        Plot the trace of the values, a time series showing the evolution of the parameter values for the MCMC sampler.
        Only a single parameter element trace is shown per plot, and all plots are shown on the same plotting window. In
        particular, if a parameter is array-valued, then the traces for each element of its array are plotted on a
        separate subplot.

        :param name: The parameter name.
        """
        traces = self._samples[name]  # Get the sampled parameter values
        if traces.ndim == 1:
            # Parameter is scalar valued, so just make a single trace plot
            plt.plot(traces, '.')
            plt.title(name)
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            for i in xrange(traces.shape[1]):
                # Plot each element of this parameters' elements separately
                plt.subplot(traces.shape[1], 1, i + 1)
                plt.plot(traces[:, i], '.', markersize=2)
                if i == 0:
                    # Add plot title
                    plt.title(name)

        plt.show()

    def plot_1dpdf(self, name):
        """
        Plot histograms of the parameter values generated by the MCMC sampler. If the parameter is array valued then
        histograms of all of the parameter's elements will be plotted.

        :param name: The parameter name.
        """
        traces = self._samples[name]  # Get teh sampled parameter values
        if traces.ndim == 1:
            # Parameter is scalar valued, so this is easy
            plt.hist(traces, bins=50, normed=True)
            plt.title(name)
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            for i in xrange(traces.shape[1]):
                # Plot each element of this parameters' elements separately
                npanels = int(np.sqrt(traces.shape[1])) + 1
                plt.subplot(npanels, npanels, i + 1)
                plt.hist(traces[:, i], bins=50, normed=True)
                if i == 0:
                    # Add plot title
                    plt.title(name)

        plt.show()

    def plot_autocorr(self, name):
        """
        Plot the autocorrelation functions of the traces for a parameter. If the parameter is array-value then
        autocorrelation plots for each of the parameter's elements will be plotted.

        :param name: The parameter name.
        """
        traces = self._samples[name]  # Get the sampled parameter values

        if traces.ndim == 1:
            # Parameter is scalar valued, so this is easy
            centered_trace = traces - traces.mean()
            lags, acf, not_needed1, not_needed2 = plt.acorr(centered_trace, maxlags=traces.size, lw=2)
            acf = acf[acf.size / 2:]
            lags = lags[lags.size / 2:]
            # Compute the autocorrelation time scale and then resize the plot
            acf_timescale = self.autocorr_timescale(traces)
            plt.xlim(0, 5.0 * acf_timescale)
            plt.title(name)
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            for i in xrange(traces.shape[1]):
                # Plot each element of this parameter separately
                plt.subplot(traces.shape[1], 1, i + 1)
                centered_trace = traces[:, i] = np.mean(traces[:, i])
                lags, acf, not_needed1, not_needed2 = plt.acorr(centered_trace, maxlags=traces.shape[0], lw=2)
                acf = acf[acf.size / 2:]
                lags = lags[lags.size / 2:]
                # Compute the autocorrelation time scale and then resize the plot
                acf_timescale = self.autocorr_timescale(traces[:, i])
                plt.xlim(0, 5.0 * acf_timescale)
                if i == 0:
                    # Add plot title
                    plt.title(name)

        plt.show()

    def plot_parameter(self, name, pindex=0):
        """
        Simultaneously plots the trace, histogram, and autocorrelation of this parameter's values. If the parameter
        is array-valued, then the user must specify the index of the array to plot, as these are all 1-d plots on a
        single plotting window.

        :param name: The name of the parameter that the plots are made for.
        :param pindex: If the parameter is array-valued, then this is the index of the array that the plots are made
                       for.
        """
        traces = self._samples[name]
        plot_title = name
        if traces.ndim > 1:
            # Parameter is array valued, grab the column corresponding to pindex
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))
            traces = traces[:, pindex]
            plot_title = name + ", element " + str(pindex)

        # First plot the trace
        plt.subplot(211)
        plt.plot(traces, '.', markersize=2)
        plt.xlim(0, traces.size)
        plt.xlabel("Iteration")
        plt.ylabel("Value")
        plt.title(plot_title)

        # Now add the histogram of values to the trace plot axes
        pdf, bin_edges = np.histogram(traces, bins=25)
        bin_edges = bin_edges[0:pdf.size]
        # Stretch the PDF so that it is readable on the trace plot when plotted horizontally
        pdf = pdf / float(pdf.max()) * 0.34 * traces.size
        # Add the histogram to the plot
        plt.barh(bin_edges, pdf, height=bin_edges[1] - bin_edges[0], alpha=0.75)

        # Finally, plot the autocorrelation function of the trace
        plt.subplot(212)
        centered_trace = traces - traces.mean()
        lags, acf, not_needed1, not_needed2 = plt.acorr(centered_trace, maxlags=traces.size - 1, lw=2)
        acf = acf[acf.size / 2:]
        plt.ylabel("ACF")
        plt.xlabel("Lag")

        # Compute the autocorrelation timescale, and then reset the x-axis limits accordingly
        acf_timescale = self.autocorr_timescale(traces)
        plt.xlim(0, 5.0 * acf_timescale)
        plt.show()

    def posterior_summaries(self, name):
        """
        Print out the posterior medians, standard deviations, and 68th, 95th, and 99th credibility intervals.

        :param name: The name of the parameter for which the summaries are desired.

        See the documentation for MCMCSample.plot_trace for further information.
        """
        traces = self._samples[name]  # Get the sampled parameter values
        effective_nsamples = self.effective_samples(name)  # Get the effective number of independent samples
        if traces.ndim == 1:
            # Parameter is scalar valued, so this is easy
            print "Posterior summary for parameter", name
            print "----------------------------------------------"
            print "Effective number of independent samples:", effective_nsamples
            print "Median:", np.median(traces)
            print "Standard deviation:", np.std(traces)
            print "68% credibility interval:", np.percentile(traces, (16.0, 84.0))
            print "95% credibility interval:", np.percentile(traces, (2.5, 97.5))
            print "99% credibility interval:", np.percentile(traces, (0.5, 99.5))
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            for i in xrange(traces.shape[1]):
                # give summary for each element of this parameter separately
                # Parameter is scalar valued, so this is easy
                print "Posterior summary for parameter", name, " element", i
                print "----------------------------------------------"
                print "Effective number of independent samples:", effective_nsamples[i]
                print "Median:", np.median(traces[:, i])
                print "Standard deviation:", np.std(traces[:, i])
                print "68% credibility interval:", np.percentile(traces[:, i], (16.0, 84.0))
                print "95% credibility interval:", np.percentile(traces[:, i], (2.5, 97.5))
                print "99% credibility interval:", np.percentile(traces[:, i], (0.5, 99.5))